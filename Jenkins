// jenkinsfile


agent any // Indicates that the pipeline will run on any available agent

// Define las herramientas necesarias. Asegúrate de que Maven y JDK estén configurados en Jenkins.
tools {
    maven 'Maven 4.0.0' // Reemplaza con la versión de Maven que uses
    jdk 'JDK 21'        // Reemplaza con el nombre de tu instalación de JDK en Jenkins
}

// Define los parámetros para la pipeline (útil para despliegues manuales o versiones específicas)
parameters {
    string(name: 'GCP_PROJECT_ID', defaultValue: 'java-arena', description: 'GCP project ID')
    string(name: 'GCR_IMAGE_NAME', defaultValue: 'java-arena-auth-service', description: 'Nombre de la imagen en GCR')
    string(name: 'APP_VERSION', defaultValue: '1.0.0', description: 'Versión de la aplicación/imagen Docker')
    string(name: 'GKE_CLUSTER_NAME', defaultValue: 'javaarena', description: 'Nombre de tu clúster GKE')
    string(name: 'GKE_CLUSTER_ZONE', defaultValue: 'us-central1', description: 'Zona de tu clúster GKE')
}


pipeline {

    // Opciones globales para la pipeline
    options {
        // Habilita el guardado de artefactos (por ejemplo, el JAR compilado)
        // artifacts(true) // Descomentar si necesitas guardar artefactos
        // Limita el número de builds históricos
        buildDiscarder(logRotator(numToKeepStr: '10'))
    }

    // Definición de las etapas de la pipeline
    stages {

        stage('Checkout') {
            steps {
            cleanWs()
                // Clones your Git repository
                git branch: 'master', url: 'https://github.com/Fernandiotkd/javaarena-auth-service'
            }
        }

        stage('Build Java App') {
            steps {
                // Commands to build your application would go here
                // Example for a Java application with Maven:
                //sh 'mvn clean install'
                sh "mvn clean package -DskipTests" // -DskipTests para saltar tests en la build de CI/CD
            }
        }

        stage('Test') {
            steps {
                // Commands to run your unit/integration tests would go here
                // Example for Maven:
                sh 'mvn test'
                // Example for Node.js:
                // sh 'npm test'
            }
        }

        stage('Code Analysis') {
            steps {
                // Optional: Integrate with code analysis tools like SonarQube
                // sh 'mvn sonar:sonar'
            }
        }

        // Etapa 3: Construir la imagen Docker
        stage('Build Docker Image') {
            steps {
                script {
                    // Define el nombre completo de la imagen para GCR
                    def gcrImage = "gcr.io/${params.GCP_PROJECT_ID}/${params.GCR_IMAGE_NAME}:${params.APP_VERSION}"
                    echo "Construyendo imagen Docker: ${gcrImage}"
                    // Construye la imagen Docker usando el Dockerfile en el directorio actual
                    // El comando 'docker build' se ejecuta en el agente de Jenkins
                    sh "docker build -t ${gcrImage} ."
                }
            }
        }

        stage('Push Docker Image to GCR') {
            steps {
                script {
                    // Define el nombre completo de la imagen para GCR
                    def gcrImage = "gcr.io/${params.GCP_PROJECT_ID}/${params.GCR_IMAGE_NAME}:${params.APP_VERSION}"
                    echo "Empujando imagen Docker a GCR: ${gcrImage}"

                    // Autentica Docker con GCR usando las credenciales de la cuenta de servicio de GCP
                    // El ID 'gcp-service-account' debe coincidir con el ID que le diste a tus credenciales en Jenkins
                    withCredentials([googleServiceAccountKey('gcp-service-account')]) {
                        // El comando 'gcloud auth configure-docker' configura Docker para usar GCR
                        sh "gcloud auth configure-docker"
                        // Empuja la imagen al registro
                        sh "docker push ${gcrImage}"
                    }
                }
            }
        }

        stage('Deploy to Kubernetes') {
                    steps {
                        script {
                            echo "Desplegando en Kubernetes..."

                            // Configura kubectl para usar el clúster GKE
                            // Esto es necesario para que kubectl sepa a qué clúster conectarse
                            sh "gcloud container clusters get-credentials ${params.GKE_CLUSTER_NAME} --zone ${params.GKE_CLUSTER_ZONE} --project ${params.GCP_PROJECT_ID}"

                            // Reemplaza el placeholder de la imagen en el deployment.yaml
                            // Esto asegura que el deployment siempre use la imagen recién construida
                            sh "sed -i 's|gcr.io/tu-proyecto-id/mi-app:1.0|gcr.io/${params.GCP_PROJECT_ID}/${params.GCR_IMAGE_NAME}:${params.APP_VERSION}|g' deployment.yaml"

                            // Aplica los archivos de despliegue y servicio a Kubernetes
                            sh "kubectl apply -f deployment.yaml"
                            sh "kubectl apply -f service.yaml"

                            echo "Despliegue completado. Esperando IP externa del servicio..."
                            // Espera a que el balanceador de carga asigne una IP externa
                            // Este bucle intentará obtener la IP hasta que esté disponible
                            def externalIp = ""
                            timeout(time: 5, unit: 'MINUTES') { // Espera hasta 5 minutos
                                while (externalIp == null || externalIp == "") {
                                    sleep 10 // Espera 10 segundos antes de reintentar
                                    try {
                                        externalIp = sh(script: "kubectl get service mi-app-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}'", returnStdout: true).trim()
                                    } catch (Exception e) {
                                        echo "Error al obtener la IP externa, reintentando... (${e.message})"
                                    }
                                }
                            }
                            echo "Aplicación accesible en http://${externalIp}"
                        }
                    }
                }

    }

    post {
        always {
            // Limpia el directorio de trabajo del agente después de cada build
            cleanWs()
        }
        success {
            echo 'Pipeline completada exitosamente!'
        }
        failure {
            echo 'Pipeline falló. Revisa los logs para más detalles.'
        }
    }
}